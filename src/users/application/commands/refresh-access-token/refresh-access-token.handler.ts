import { UnauthorizedException } from '@nestjs/common';
import { CommandHandler, ICommandHandler } from '@nestjs/cqrs';
import { RefreshAccessTokenCommand } from '..';
import { UnitOfWork } from '../../../../shared/domain/repositories';
import { UniqueId } from '../../../../shared/domain/value-objects';
import { RefreshToken, User } from '../../../domain/entities';
import {
  RefreshTokenRepository,
  UserRepository,
} from '../../../domain/repositories';
import { IpAddress } from '../../../domain/value-objects';
import { AuthTokensDto } from '../../dtos';
import { userToOutputUserDto } from '../../mappings';
import { TokenService, UniqueIdGeneratorService } from '../../services';

@CommandHandler(RefreshAccessTokenCommand)
export class RefreshAccessTokenHandler
  implements ICommandHandler<RefreshAccessTokenCommand>
{
  constructor(
    private readonly unitOfWork: UnitOfWork,
    private readonly userRepository: UserRepository,
    private readonly refreshTokenRepository: RefreshTokenRepository,
    private readonly tokenService: TokenService,
    private readonly uniqueIdGeneratorService: UniqueIdGeneratorService,
  ) {}

  async execute(command: RefreshAccessTokenCommand): Promise<AuthTokensDto> {
    const refreshTokenToUseId = UniqueId.create(command.refreshTokenToUse);
    const ipAddress = IpAddress.create(command.ipAddress);

    const user = await this.userRepository.getOneByRefreshTokenId(
      refreshTokenToUseId,
    );
    if (!user) throw new UnauthorizedException();

    const refreshTokenToUse = user.getRefreshToken(refreshTokenToUseId);
    if (!refreshTokenToUse) throw new UnauthorizedException();

    // Check if the refresh token is valid
    if (refreshTokenToUse.wasReplaced || refreshTokenToUse.isRevoked) {
      // Revoke all valid tokens generated by the User
      const refreshTokensByUserId =
        await this.userRepository.getAllRefreshTokensByUserId(user.id);

      refreshTokensByUserId
        .filter((rt) => rt.isValid)
        .forEach((rt) => {
          rt.revoke();
          this.userRepository.updateRefreshToken(rt);
        });

      // Revoke all valid tokens generated by the Ip
      const refreshTokensByIp =
        await this.userRepository.getAllRefreshTokensByIpAddress(ipAddress);

      refreshTokensByIp
        .filter((rt) => rt.isValid)
        .forEach((rt) => {
          rt.revoke();
          this.userRepository.updateRefreshToken(rt);
        });

      // Commit changes
      await this.unitOfWork.commitChanges();
    }

    if (!refreshTokenToUse.isValid) throw new UnauthorizedException();

    // Generate the access token
    const access_token = this.generateAccessToken(user);

    // Generate the new refresh token
    const newRefreshToken = RefreshToken.create(
      this.uniqueIdGeneratorService.generateId(),
      ipAddress,
    );

    // Update the user
    user.addRefreshToken(newRefreshToken);

    // Update the Refresh Token to use
    user.replaceRefreshToken(refreshTokenToUse.id, newRefreshToken);

    // Save changes in persistence
    this.userRepository.update(user);
    await this.unitOfWork.commitChanges();

    return {
      access_token,
      refresh_token: newRefreshToken.id.getId,
    };
  }

  private generateAccessToken(user: User): string {
    const outputUserDto = userToOutputUserDto(user);

    const { id, ...body } = outputUserDto;
    const payload = { sub: id, ...body };
    return this.tokenService.signPayload(payload);
  }
}
