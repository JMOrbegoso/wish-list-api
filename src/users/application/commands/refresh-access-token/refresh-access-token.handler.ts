import { UnauthorizedException } from '@nestjs/common';
import { CommandHandler, ICommandHandler } from '@nestjs/cqrs';
import { RefreshAccessTokenCommand } from '..';
import { UnitOfWork } from '../../../../shared/domain/repositories';
import { RefreshToken, RefreshTokenId, User } from '../../../domain/entities';
import { UserRepository } from '../../../domain/repositories';
import { IpAddress } from '../../../domain/value-objects';
import { AuthTokensDto } from '../../dtos';
import { userToOutputUserDto } from '../../mappings';
import { TokenService, UniqueIdGeneratorService } from '../../services';

@CommandHandler(RefreshAccessTokenCommand)
export class RefreshAccessTokenHandler
  implements ICommandHandler<RefreshAccessTokenCommand>
{
  constructor(
    private readonly unitOfWork: UnitOfWork,
    private readonly userRepository: UserRepository,
    private readonly tokenService: TokenService,
    private readonly uniqueIdGeneratorService: UniqueIdGeneratorService,
  ) {}

  async execute(command: RefreshAccessTokenCommand): Promise<AuthTokensDto> {
    const refreshTokenToReplaceId = RefreshTokenId.create(
      command.refreshTokenToReplace,
    );
    const ipAddress = IpAddress.create(command.ipAddress);

    const user = await this.userRepository.getOneByRefreshTokenId(
      refreshTokenToReplaceId,
    );
    if (!user) throw new UnauthorizedException();

    const refreshTokenToReplace = user.getRefreshToken(refreshTokenToReplaceId);
    if (!refreshTokenToReplace) throw new UnauthorizedException();

    // Check if the refresh token is used or revoked to auto-revoke all the valid tokens of the User and Ip address
    if (refreshTokenToReplace.wasReplaced || refreshTokenToReplace.isRevoked) {
      // Revoke all valid tokens generated by the User
      const refreshTokensByUserId =
        await this.userRepository.getAllRefreshTokensByUserId(user.id);

      refreshTokensByUserId
        .filter((rt) => rt.isValid)
        .forEach((rt) => {
          rt.revoke();
          this.userRepository.updateRefreshToken(rt);
        });

      // Revoke all valid tokens generated by the Ip
      const refreshTokensByIp =
        await this.userRepository.getAllRefreshTokensByIpAddress(ipAddress);

      refreshTokensByIp
        .filter((rt) => rt.isValid)
        .forEach((rt) => {
          rt.revoke();
          this.userRepository.updateRefreshToken(rt);
        });

      // Commit changes
      await this.unitOfWork.commitChanges();
    }

    // Check if the token is not valid (Expired, revoked or used)
    if (!refreshTokenToReplace.isValid) throw new UnauthorizedException();

    // Check if the user can refresh auth tokens
    if (user.isDeleted) throw new UnauthorizedException('User is deleted.');
    if (user.isBlocked) throw new UnauthorizedException('User is blocked.');
    if (!user.isVerified)
      throw new UnauthorizedException('User is not verified.');

    // Generate the access token
    const access_token = this.generateAccessToken(user);

    // Generate the new refresh token
    const refreshTokenId = RefreshTokenId.create(
      this.uniqueIdGeneratorService.generateId(),
    );
    const newRefreshToken = RefreshToken.create(refreshTokenId, ipAddress);

    // Update the User refresh Tokens
    user.replaceRefreshToken(refreshTokenToReplace.id, newRefreshToken);

    // Get the used refresh Token
    const refreshTokenReplaced = user.refreshTokens.find((rt) =>
      rt.id.equals(refreshTokenToReplace.id),
    );

    // Save changes in persistence
    this.userRepository.addRefreshToken(newRefreshToken, user.id);
    this.userRepository.updateRefreshToken(refreshTokenReplaced);
    await this.unitOfWork.commitChanges();

    return {
      access_token,
      refresh_token: newRefreshToken.id.value.toString(),
    };
  }

  private generateAccessToken(user: User): string {
    const outputUserDto = userToOutputUserDto(user);

    const { id, ...body } = outputUserDto;
    const payload = { sub: id, ...body };
    return this.tokenService.signPayload(payload);
  }
}
